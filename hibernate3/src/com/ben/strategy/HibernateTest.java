package com.ben.strategy;

import java.util.List;

import org.hibernate.Hibernate;
import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.cfg.Configuration;
import org.hibernate.service.ServiceRegistry;
import org.hibernate.service.ServiceRegistryBuilder;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;

public class HibernateTest {
	private SessionFactory sessionFactory;
	private Session session;
	private Transaction transaction;
	//生产环境中Session 和Transaction 不能作为成员变量，会有并发问题

	@Before
	public void init()
	{
		Configuration configuration = new Configuration().configure();
		ServiceRegistry serviceRegistry = 
				new ServiceRegistryBuilder().applySettings(configuration.getProperties())
											.buildServiceRegistry();
		sessionFactory = configuration.buildSessionFactory(serviceRegistry);
		
		session = sessionFactory.openSession();
		transaction = session.beginTransaction();
	}
	
	@After
	public void destroy()
	{
		transaction.commit();
		session.close();
		sessionFactory.close();
	}
	@Test
	public void testMany2OneStrategy()
	{
//		Order order = (Order) session.get(Order.class, 1);
//		System.out.println(order.getCustomer().getCustomerName());
		
		List<Order> orders = session.createQuery("FROM Order o").list();
		for(Order o:orders)
		{
			if(o.getCustomer() != null)
			{
				System.out.println(o.getCustomer().getCustomerName());
			}
		}
		//1. lazy 取值为proxy 和false 分别代表采用延迟检索和立即检索
		//2. fetch 取值为join ， 表示使用迫切左外连接的方式初始化n 关联的1 的一端的属性（orders）
		//忽略lazy 属性
		//3. batch-size 该属性需要设置在1 的一端的class 元素中：
		//<class name="Customer" table="CUSTOMERS" lazy="true" batch-size="5">
		//作用： 一次初始化1 这一段代理对象的个数
	}
	@Test
	public void testSetFetch2()
	{
		Customer customer = (Customer) session.get(Customer.class,1);
		System.out.println(customer.getOrders().size());
	}
	@Test
	public void testSetFetch()
	{
		List<Customer> customers = session.createQuery("FROM Customer").list();
		
		System.out.println(customers.size());
		
		for(Customer c:customers)
		{
			if(c.getOrders() != null)
			{
				System.out.println(c.getOrders().size());
			}
		}
		//set 集合的 fetch 属性：确定初始化orders 的查询语句的形式
		//1. 默认值为 select . 通过正常的方式来初始化集合
		//2. 可以取值为 subselect ， 通过子查询的方式来初始化所有的 set 集合， 
		//子查询作为where 子句的in 的条件出现， 子查询查询所有1  的一端ID ，此时lazy 有效
		//但batch-size 无效
		//3. 若取值为join ， 则
		//3.1 在加载1 的一端的对象时， 使用迫切左外连接（使用左外连接进行查询， 
		//且把集合属性进行初始化）的方式检索n 的一端的集合属性 
		//3.2 忽略lazy 属性
		//3.3 HQL 查询忽略fetch=join 的取值
	}
	@Test
	public void testSetBatchSize()
	{
		List<Customer> customers = session.createQuery("FROM Customer").list();
		
		System.out.println(customers.size());
		
		for(Customer c:customers)
		{
			if(c.getOrders() != null)
			{
				System.out.println(c.getOrders().size());
			}
		}
		//set 元素的batch-size 属性可以设定一次初始化set 集合的数量
	}
	@Test
	public void testOne2ManyLevelStrategy()
	{
		Customer customer = (Customer) session.get(Customer.class, 1);
		System.out.println(customer.getCustomerName());
		
		System.out.println(customer.getOrders().size());
		
		Order order = new Order();
		order.setOrderId(1);
		System.out.println(customer.getOrders().contains(order));
		
		//对集合的代理对象进行初始化
		Hibernate.initialize(customer.getOrders());
		
		//------------ set 的 lazy 属性-----------------
		//1. 1-n 或 n-n 的集合属性默认使用懒加载检索策略
		//2. 可以通过设置set 的lazy 属性来修改默认的检索策略， 默认为true ， 并不建议设置为false
		//3. lazy 还可以设置为 extra， 增强的延迟检索， 该取值会尽可能的延迟集合初始化的时机
	}
	@Test
	public void testClassLevelStrategy()
	{
		Customer customer = (Customer) session.load(Customer.class, 1);
		System.out.println(customer.getClass());
		
		System.out.println(customer.getCustomerId());
		System.out.println(customer.getCustomerName());
	}
}
